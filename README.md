# authentication-csharp

这是一个用 C# 写的授权验证程序的小例子, 实现了

* 密钥对文件的生成
* 获取硬件信息
* 通过公钥文件对硬件信息进行加密
* 通过私钥文件进行解密, 并对授权信息进行签名
* 通过公钥文件对授权信息的签名进行验证
* 用 3DES 算法, 对硬件信息做了一个简单的对称加密和解密

基本流程如下:

1. 采集硬件信息, 采集了 CPU 序列号, 主板序列号和 MAC 地址, 将这三个信息组合成一个 Dictionary, 并转成 byte[]
2. 如果未找到授权文件 default.cert, 将硬件信息通过 RSA 公钥加密, 写入文件 identify.dat, 并提示用户将这个文件发给厂家
3. 厂家收到用户提交的 identify.dat 文件后, 通过 RSA 私钥解密, 还原出原始的硬件信息 Dictionary, 然后往里面添加一些其它的信息, 并再次转换为 byte[]
4. 由于 C# 提供的 RSA 算法类, 只能通过公钥加密, 不能反过来使用私钥加密, 所以为了避免泄漏具体采集了哪些硬件信息, 在签名前使用 3DES 算法, 对授权信息做了一次加密
5. 然后将"原始信息签名+原始信息加密"组合在一起, 生成授权文件
6. 用户得到授权文件后, 通过软件中的导入按钮, 会复制到程序文件夹下面的 default.cert, 然后提示用户重启
7. 重启程序后, 由于检查到存在 default.cert, 将其内容分成两段, 先用 3DES 将后面一段解密, 再用 RSA 公钥验证前面一段签名
8. 验证通过之后, 再此读取硬件信息, 与证书文件中的硬件信息做比较, 如果比对通过, 则授权验证完成
9. 同时读取授权文件中附加的其它限制, 比如授权使用时间等, 做进一步的判断

这里面目前还有几个地方可以改进

1. 3DES 加密使用的是一个固定的密钥, 可以改为随机密钥, 并写在授权文件内, 不过从安全性来说, 没太大区别
2. 根据 https://www.cryptopp.com/wiki/Authenticated_Encryption 中的介绍, 目前较为安全的算法是先加密, 然后对加密后的内容签名, 目前是对加密前的内容签名, 这个可以改进
3. RSA 算法的公钥和私钥其实是相对的, 理论上可以用公钥加密, 私钥解密, 也可以用私钥加密, 公钥解密, 但是目前 C# 限制了只能用公钥加密, 而私钥只能用于签名, 这个我想了一些办法, 最终还是无法绕过去, 只能放弃, 如果真要实现, 只能不用 C# 自带的类, 而是用 CryptoPP
4. 由于硬件信息并不多, 目前是直接用 RSA 对硬件信息进行加密, 如果硬件信息比较多的话, 最好还是用 RSA 加密一个密钥, 然后用密钥进行加解密
